面向对象的设计原则
    依赖倒置原则(DIP)
        高层模块不依赖底层模块，高层和底层模块依赖于抽象
        抽象不依赖于实现细节，实现细节依赖于抽象

    开放封闭原则(OCP)
        对扩展开放，对更改封闭
        类模块应该是可扩展的，但是不可修改的


    单一职责原则(SRP)
        一个类应该仅有一个引起他变化的原因
        变化的方向隐含着类的责任

    Lisk替换原则(LSP)
        子类必须能够替换他们的基类(IS-A)
        继承表达类型抽象

    接口隔离原则(ISP)
        不应该强迫客户程序依赖他们不用的方法
        接口应该小而完备

    优先使用对象组合，而不是类继承
        类继承通常为"白箱复用"，对象组合通常为"黑箱复用"
        继承在某种程度上破坏了封装性,子类父类耦合度高
        而对象组合则只要求被组合的对象具有良好定义的接口,耦合度低

    封装变化点
        使用封装来创建对象之间的分界层,让设计者可以在分界层一侧进行修改,而不会对另一侧产生不良的影响从而实现层次间的耦合
    
    针对接口编程,而不是针对实现编程
        不将变量类型声明为某个特定的具体类,而是声明为某个接口
        客户程序无需获知对象的具体类型,只需要知道对象所具有的接口
        减少系统中各部分的依赖关系,从而实现"高内聚、松耦合"的类型设计方案



模板方法
    重构关键技法
        静态->动态
        早绑定->晚绑定
        继承->组合
        编译时依赖->运行时依赖
        紧耦合->松耦合


    动机
        在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因(比如框架与应用之间的关系)而无法和任务的整体结构同时实现。

        如何在确定稳定结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

    模式定义
        定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method 使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤


        继承+多态


        要点总结
            Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用，他用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构

            除了可以灵活应对子步骤的变化外，"不要调用我，让我来调用你"的反向控制结构是Template Method的典型应用

            在具体实现方面，被Template Method嗲用的虚方法可以经由实现，也可以没有任何实现(抽象方法、纯虚方法)但一般推荐奖他们设置为protected方法


策略模式

    动机
        在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象编的异常复杂，而且有时候支持不使用的算法也是一个性能负担。

        如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

    模式定义
        定义一系列算法，把他们一个个封装起来，并且是他们可以互相替换(变化)。该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。


    要点总结
        Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换

        Strategy模式提供了用条件判断语句意外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式

        如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。


观察着模式

    是一种组件协作模式

    动机
        在软件构建过程中，我们需要为某些对象建立一种"通知依赖关系"-----一个对象(目标对象)的状态发生改变，所有的依赖对象(观察着对象)都讲得到通知。如果这样的依赖关系过于紧密，将使软件不能很好的抵御变化

        使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合

    模式定义
        定义对象间的一种一对多(变化)的依赖关系，以便当一个对象(Subject)的状态发生改变，所有的依赖对象都得到通知并自动更新。


    要点总结
        使用面向对象的抽象，Observer模式使得我们可以独立的改变目标与观察者，从而使两者之间的依赖关系达致松耦合

        目标发送通知时，无需指定观察者，通知(可以携带通知信息作为参数)会自动传播

        观察者自己决定是否需要订阅通知，目标对象对此一无所知。

        Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。



装饰模式

    是一种单一职责模式
        在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

    动机
        在某些情况下我们可能会"过度的使用继承来扩展对象的功能"，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并随着子类的增多(扩展功能的增多)，各种子类的组合(扩展功能的组合)会导致更多子类的膨胀

        如何使"对象功能的扩展"能够根据需要来动态的实现?同时避免"扩展功能的增多"带来的子类膨胀问题?从而使得任何"功能扩展变化"所导致的影响降为最低?

    模式定义

        动态(组合)地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类(继承)更为灵活(消除重复代码&减少子类个数)

    要点总结
        通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的"灵活性差"和"多子类衍生问题"

        Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。


        Decorator模式的目的并非解决"多子类衍生的多继承"问题，Decorator模式应用的要点在于解决"主体类在多个方向上的扩展功能"--------是为"装饰"的含义



    动机
    模式定义
    要点总结

    动机
    模式定义
    要点总结


    动机
    模式定义
    要点总结


    动机
    模式定义
    要点总结


    动机
    模式定义
    要点总结


    动机
    模式定义
    要点总结


    动机
    模式定义
    要点总结


    动机
    模式定义
    要点总结